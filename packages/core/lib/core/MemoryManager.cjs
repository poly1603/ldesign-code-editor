"use strict";var e=Object.defineProperty,t=(t,r,s)=>(((t,r,s)=>{r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[r]=s})(t,"symbol"!=typeof r?r+"":r,s),s);class r{constructor(){t(this,"thresholds",{warning:75,critical:90}),t(this,"callbacks",new Set),t(this,"monitoringInterval",null),t(this,"weakReferences",new WeakMap),t(this,"referenceRegistry",new FinalizationRegistry(e=>{}))}setThresholds(e){this.thresholds={...this.thresholds,...e}}getMemoryStats(){if(!("memory"in performance))return null;const e=performance.memory,t=e.usedJSHeapSize/e.jsHeapSizeLimit*100;return{usedHeapSize:e.usedJSHeapSize,totalHeapSize:e.totalJSHeapSize,heapLimit:e.jsHeapSizeLimit,usagePercentage:t,timestamp:Date.now()}}checkMemoryStatus(){const e=this.getMemoryStats();return e?e.usagePercentage>=this.thresholds.critical?"critical":e.usagePercentage>=this.thresholds.warning?"warning":"normal":null}onMemoryChange(e){return this.callbacks.add(e),()=>{this.callbacks.delete(e)}}startMonitoring(e=5e3){this.monitoringInterval||(this.monitoringInterval=setInterval(()=>{const e=this.getMemoryStats();if(e){this.callbacks.forEach(t=>t(e));const t=this.checkMemoryStatus();"critical"===t&&this.triggerGarbageCollection()}},e))}stopMonitoring(){this.monitoringInterval&&(clearInterval(this.monitoringInterval),this.monitoringInterval=null)}triggerGarbageCollection(){if(globalThis.gc)try{globalThis.gc()}catch(e){}}registerObject(e,t){this.weakReferences.set(e,t),this.referenceRegistry.register(e,t)}async detectLeaks(e=5e3){const t=new Map;for(let e=0;e<100;e++){const r={test:e},s=`test-${e}`;t.set(r,s),this.registerObject(r,s)}return t.clear(),this.triggerGarbageCollection(),await new Promise(t=>setTimeout(t,e)),[]}clearLargeObjects(e,t=()=>!0){let r=0;for(let s=e.length-1;s>=0;s--)t(e[s])&&(e.splice(s,1),r++);return r}deduplicateStrings(e){const t=new Set,r=[];for(const s of e)t.has(s)||(t.add(s),r.push(s));return r}estimateObjectSize(e){const t=new WeakSet;return function e(r){if(null==r)return 0;switch(typeof r){case"boolean":return 4;case"number":return 8;case"string":return 2*r.length;case"object":return t.has(r)?0:(t.add(r),Array.isArray(r)?r.reduce((t,r)=>t+e(r),0):Object.keys(r).reduce((t,s)=>t+2*s.length+e(r[s]),0));default:return 0}}(e)}createSnapshot(){return{timestamp:Date.now(),stats:this.getMemoryStats(),status:this.checkMemoryStatus()}}compareSnapshots(e,t){if(!e.stats||!t.stats)return null;const r=t.stats.usedHeapSize-e.stats.usedHeapSize,s=t.timestamp-e.timestamp;return{heapGrowth:r,timeElapsed:s,growthRate:r/(s/1e3)}}formatBytes(e,t=2){if(0===e)return"0 Bytes";const r=t<0?0:t,s=Math.floor(Math.log(e)/Math.log(1024));return parseFloat((e/Math.pow(1024,s)).toFixed(r))+" "+["Bytes","KB","MB","GB"][s]}generateReport(){const e=this.getMemoryStats();return e?`\nMemory Report (${new Date(e.timestamp).toLocaleString()})\n==========================================\nUsed Heap: ${this.formatBytes(e.usedHeapSize)}\nTotal Heap: ${this.formatBytes(e.totalHeapSize)}\nHeap Limit: ${this.formatBytes(e.heapLimit)}\nUsage: ${e.usagePercentage.toFixed(2)}%\nStatus: ${this.checkMemoryStatus()}\n==========================================\n    `.trim():"Memory statistics not available"}dispose(){this.stopMonitoring(),this.callbacks.clear()}}const s=new r;exports.MemoryManager=r,exports.globalMemoryManager=s;
//# sourceMappingURL=MemoryManager.cjs.map
