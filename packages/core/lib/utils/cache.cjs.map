{"version":3,"file":"cache.cjs","sources":["../../src/utils/cache.ts"],"sourcesContent":["/**\n * 缓存工具\n * 实现多种缓存策略和存储机制\n */\n\nexport interface CacheOptions {\n  maxSize?: number\n  ttl?: number // Time to live in milliseconds\n  onEvict?: (key: string, value: unknown) => void\n}\n\nexport interface CacheEntry<T> {\n  value: T\n  timestamp: number\n  hits: number\n}\n\n/**\n * LRU (Least Recently Used) 缓存\n */\nexport class LRUCache<T = unknown> {\n  private cache = new Map<string, CacheEntry<T>>()\n  private maxSize: number\n  private ttl: number\n  private onEvict?: (key: string, value: T) => void\n\n  constructor(options: CacheOptions = {}) {\n    this.maxSize = options.maxSize || 100\n    this.ttl = options.ttl || Infinity\n    this.onEvict = options.onEvict as ((key: string, value: T) => void) | undefined\n  }\n\n  /**\n   * 获取缓存值\n   */\n  get(key: string): T | undefined {\n    const entry = this.cache.get(key)\n\n    if (!entry) {\n      return undefined\n    }\n\n    // 检查是否过期\n    if (this.isExpired(entry)) {\n      this.delete(key)\n      return undefined\n    }\n\n    // 更新访问信息\n    entry.hits++\n    entry.timestamp = Date.now()\n\n    // 移到最后（LRU）\n    this.cache.delete(key)\n    this.cache.set(key, entry)\n\n    return entry.value\n  }\n\n  /**\n   * 设置缓存值\n   */\n  set(key: string, value: T): void {\n    // 如果已存在，先删除\n    if (this.cache.has(key)) {\n      this.cache.delete(key)\n    }\n\n    // 如果达到最大容量，删除最早的项\n    if (this.cache.size >= this.maxSize) {\n      const firstKey = this.cache.keys().next().value\n      if (firstKey) {\n        this.delete(firstKey)\n      }\n    }\n\n    this.cache.set(key, {\n      value,\n      timestamp: Date.now(),\n      hits: 0,\n    })\n  }\n\n  /**\n   * 删除缓存\n   */\n  delete(key: string): boolean {\n    const entry = this.cache.get(key)\n    if (entry && this.onEvict) {\n      this.onEvict(key, entry.value)\n    }\n    return this.cache.delete(key)\n  }\n\n  /**\n   * 检查是否存在\n   */\n  has(key: string): boolean {\n    const entry = this.cache.get(key)\n    if (!entry) {\n      return false\n    }\n\n    if (this.isExpired(entry)) {\n      this.delete(key)\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * 清空缓存\n   */\n  clear(): void {\n    if (this.onEvict) {\n      this.cache.forEach((entry, key) => {\n        this.onEvict!(key, entry.value)\n      })\n    }\n    this.cache.clear()\n  }\n\n  /**\n   * 获取缓存大小\n   */\n  size(): number {\n    return this.cache.size\n  }\n\n  /**\n   * 获取所有键\n   */\n  keys(): string[] {\n    return Array.from(this.cache.keys())\n  }\n\n  /**\n   * 检查是否过期\n   */\n  private isExpired(entry: CacheEntry<T>): boolean {\n    if (this.ttl === Infinity) {\n      return false\n    }\n    return Date.now() - entry.timestamp > this.ttl\n  }\n\n  /**\n   * 清理过期项\n   */\n  cleanup(): number {\n    let cleaned = 0\n    const now = Date.now()\n\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > this.ttl) {\n        this.delete(key)\n        cleaned++\n      }\n    }\n\n    return cleaned\n  }\n\n  /**\n   * 获取统计信息\n   */\n  getStats() {\n    let totalHits = 0\n    const entries = Array.from(this.cache.values())\n\n    entries.forEach((entry) => {\n      totalHits += entry.hits\n    })\n\n    return {\n      size: this.cache.size,\n      maxSize: this.maxSize,\n      totalHits,\n      averageHits: entries.length > 0 ? totalHits / entries.length : 0,\n    }\n  }\n}\n\n/**\n * WeakMap 缓存（用于对象键）\n */\nexport class WeakCache<K extends object, V> {\n  private cache = new WeakMap<K, V>()\n\n  get(key: K): V | undefined {\n    return this.cache.get(key)\n  }\n\n  set(key: K, value: V): void {\n    this.cache.set(key, value)\n  }\n\n  has(key: K): boolean {\n    return this.cache.has(key)\n  }\n\n  delete(key: K): boolean {\n    return this.cache.delete(key)\n  }\n}\n\n/**\n * 内存缓存（用于服务器端）\n */\nexport class MemoryCache<T = unknown> extends LRUCache<T> {\n  private cleanupInterval: ReturnType<typeof setInterval> | null = null\n\n  constructor(options: CacheOptions & { cleanupInterval?: number } = {}) {\n    super(options)\n\n    // 自动清理过期项\n    if (options.cleanupInterval) {\n      this.startCleanup(options.cleanupInterval)\n    }\n  }\n\n  /**\n   * 开始自动清理\n   */\n  private startCleanup(interval: number): void {\n    this.cleanupInterval = setInterval(() => {\n      this.cleanup()\n    }, interval)\n  }\n\n  /**\n   * 停止自动清理\n   */\n  stopCleanup(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval)\n      this.cleanupInterval = null\n    }\n  }\n\n  /**\n   * 销毁缓存\n   */\n  dispose(): void {\n    this.stopCleanup()\n    this.clear()\n  }\n}\n\n/**\n * 缓存装饰器\n */\nexport function Cacheable(options: CacheOptions = {}) {\n  const cache = new LRUCache(options)\n\n  return function (\n    _target: unknown,\n    _propertyKey: string,\n    descriptor: PropertyDescriptor\n  ): PropertyDescriptor {\n    const originalMethod = descriptor.value\n\n    descriptor.value = function (this: unknown, ...args: unknown[]) {\n      const key = JSON.stringify(args)\n\n      if (cache.has(key)) {\n        return cache.get(key)\n      }\n\n      const result = originalMethod.apply(this, args)\n\n      // 如果是 Promise，等待结果后缓存\n      if (result instanceof Promise) {\n        return result.then((value) => {\n          cache.set(key, value)\n          return value\n        })\n      }\n\n      cache.set(key, result)\n      return result\n    }\n\n    return descriptor\n  }\n}\n\n/**\n * Memoization 函数\n */\nexport function memoize<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  resolver?: (...args: Parameters<T>) => string\n): T {\n  const cache = new Map<string, ReturnType<T>>()\n\n  return function memoized(this: unknown, ...args: Parameters<T>): ReturnType<T> {\n    const key = resolver ? resolver(...args) : JSON.stringify(args)\n\n    if (cache.has(key)) {\n      return cache.get(key)!\n    }\n\n    const result = func.apply(this, args) as ReturnType<T>\n    cache.set(key, result)\n\n    return result\n  } as T\n}\n\n// 导出默认缓存实例\nexport const globalCache = new MemoryCache({ maxSize: 500, ttl: 5 * 60 * 1000 }) // 5分钟\n\n"],"names":["l","Object","defineProperty","s","n","e","t","enumerable","configurable","writable","value","p","LRUCache","constructor","options","__publicField","this","Map","maxSize","ttl","onEvict","get","key","entry","cache","isExpired","delete","hits","timestamp","Date","now","set","has","size","firstKey","keys","next","clear","forEach","Array","from","cleanup","cleaned","entries","getStats","totalHits","values","averageHits","length","MemoryCache","super","cleanupInterval","startCleanup","interval","setInterval","stopCleanup","clearInterval","dispose","globalCache","_target","_propertyKey","descriptor","originalMethod","args","JSON","stringify","result","apply","Promise","then","WeakMap","func","resolver"],"mappings":"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"}