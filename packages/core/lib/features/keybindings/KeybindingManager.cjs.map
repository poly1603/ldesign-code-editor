{"version":3,"file":"KeybindingManager.cjs","sources":["../../../src/features/keybindings/KeybindingManager.ts"],"sourcesContent":["/**\n * 快捷键管理器\n */\n\nimport type * as Monaco from 'monaco-editor'\n\nexport interface Keybinding {\n  id: string\n  key: string\n  command: string\n  when?: string\n  args?: unknown\n}\n\nexport class KeybindingManager {\n  private keybindings = new Map<string, Keybinding>()\n  private editor: Monaco.editor.IStandaloneCodeEditor | null = null\n\n  setEditor(editor: Monaco.editor.IStandaloneCodeEditor): void {\n    this.editor = editor\n  }\n\n  registerKeybinding(keybinding: Keybinding): void {\n    this.keybindings.set(keybinding.id, keybinding)\n\n    if (this.editor) {\n      const keyCode = this.parseKeyString(keybinding.key)\n      this.editor.addCommand(keyCode, () => {\n        this.executeCommand(keybinding.command, keybinding.args)\n      })\n    }\n  }\n\n  unregisterKeybinding(id: string): boolean {\n    return this.keybindings.delete(id)\n  }\n\n  getKeybindings(): Keybinding[] {\n    return Array.from(this.keybindings.values())\n  }\n\n  detectConflicts(): Array<{ key: string; bindings: Keybinding[] }> {\n    const keyMap = new Map<string, Keybinding[]>()\n\n    this.keybindings.forEach((binding) => {\n      if (!keyMap.has(binding.key)) {\n        keyMap.set(binding.key, [])\n      }\n      keyMap.get(binding.key)!.push(binding)\n    })\n\n    const conflicts: Array<{ key: string; bindings: Keybinding[] }> = []\n    keyMap.forEach((bindings, key) => {\n      if (bindings.length > 1) {\n        conflicts.push({ key, bindings })\n      }\n    })\n\n    return conflicts\n  }\n\n  private parseKeyString(key: string): number {\n    // 简化实现，实际需要完整的键盘映射\n    const monaco = (globalThis as { monaco?: typeof Monaco }).monaco\n    if (!monaco) return 0\n\n    const parts = key.toLowerCase().split('+')\n    let keyCode = 0\n\n    parts.forEach((part) => {\n      switch (part.trim()) {\n        case 'ctrl':\n        case 'cmd':\n          keyCode |= monaco.KeyMod.CtrlCmd\n          break\n        case 'shift':\n          keyCode |= monaco.KeyMod.Shift\n          break\n        case 'alt':\n          keyCode |= monaco.KeyMod.Alt\n          break\n      }\n    })\n\n    return keyCode\n  }\n\n  private executeCommand(command: string, args?: unknown): void {\n    this.editor?.trigger('keyboard', command, args)\n  }\n}\n\n"],"names":["constructor","__publicField","this","Map","setEditor","editor","registerKeybinding","keybinding","keybindings","set","id","keyCode","parseKeyString","key","addCommand","executeCommand","command","args","unregisterKeybinding","delete","getKeybindings","Array","from","values","detectConflicts","keyMap","forEach","binding","has","get","push","conflicts","bindings","length","monaco","globalThis","parts","toLowerCase","split","part","trim","KeyMod","CtrlCmd","Shift","Alt","trigger"],"mappings":"uMAcO,MAAA,WAAAA,GACLC,EAAAC,KAAQ,cAAc,IAAIC,KAC1BF,EAAAC,KAAQ,SAAqD,MAE7D,SAAAE,CAAUC,GACRH,KAAKG,OAASA,CAChB,CAEA,kBAAAC,CAAmBC,GAGjB,GAFAL,KAAKM,YAAYC,IAAIF,EAAWG,GAAIH,GAEhCL,KAAKG,OAAQ,CACf,MAAMM,EAAUT,KAAKU,eAAeL,EAAWM,KAC/CX,KAAKG,OAAOS,WAAWH,EAAS,KAC9BT,KAAKa,eAAeR,EAAWS,QAAST,EAAWU,OAEvD,CACF,CAEA,oBAAAC,CAAqBR,GACnB,OAAOR,KAAKM,YAAYW,OAAOT,EACjC,CAEA,cAAAU,GACE,OAAOC,MAAMC,KAAKpB,KAAKM,YAAYe,SACrC,CAEA,eAAAC,GACE,MAAMC,EAAS,IAAItB,IAEnBD,KAAKM,YAAYkB,QAASC,IACnBF,EAAOG,IAAID,EAAQd,MACtBY,EAAOhB,IAAIkB,EAAQd,IAAK,IAE1BY,EAAOI,IAAIF,EAAQd,KAAMiB,KAAKH,KAGhC,MAAMI,EAA4D,GAClE,OAAAN,EAAOC,QAAQ,CAACM,EAAUnB,KACpBmB,EAASC,OAAS,GACpBF,EAAUD,KAAK,CAAEjB,IAAAA,EAAKmB,SAAAA,MAInBD,CACT,CAEQ,cAAAnB,CAAeC,GAErB,MAAMqB,EAAUC,WAA0CD,OAC1D,IAAKA,EAAQ,OAAO,EAEpB,MAAME,EAAQvB,EAAIwB,cAAcC,MAAM,KACtC,IAAI3B,EAAU,EAEd,OAAAyB,EAAMV,QAASa,IACb,OAAQA,EAAKC,QACX,IAAK,OACL,IAAK,MACH7B,GAAWuB,EAAOO,OAAOC,QACzB,MACF,IAAK,QACH/B,GAAWuB,EAAOO,OAAOE,MACzB,MACF,IAAK,MACHhC,GAAWuB,EAAOO,OAAOG,OAKxBjC,CACT,CAEQ,cAAAI,CAAeC,EAAiBC,GACtCf,KAAKG,QAAQwC,QAAQ,WAAY7B,EAASC,EAC5C"}